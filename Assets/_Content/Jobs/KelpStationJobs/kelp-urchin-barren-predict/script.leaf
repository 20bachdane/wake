#basePath   job.kelp-urchin-barren-predict

// Beginning

:: start
@trigger    JobStarted
@cutscene

{@drKelp}  Alright, after reviewing your visual model of Site B, I have consulted with my colleagues and compiled all of the rates.
           Now we should be able to enhance our model of the Urchin Barren. 
           Head back to up to the surface and use the {h}Modeling Whiteboard{/h} to get started.
$set jobs:kelp-urchin-barren-predict.received.facts = false

::WhereToGoHelp
@trigger    RequestPartnerHelp
@when 	    scene:name != "Modeling", JobTaskTop("predictSiteB"), !jobs:kelp-urchin-barren.upgradedFacts
@cutscene
{@player} 	What am I doing again?
{@guide}	Let's head back up to the surface and use the {h}Modeling Whiteboard{/h} 

// IN MODELING

:: ModelingIntro
@trigger    SceneStart
@when       scene:name == "Modeling"
@once
@cutscene

$branch common.ringPhone

{@drKelp}   So last time we observed that {pluralnameof Urchin} eat {critter-name}Kelp{/critter-name}.
            And you also observed that {pluralnameof SeaOtter} eat {pluralnameof Urchin}.
            Let's re-open our model for the Urchin Barren.

:: ModelingSetup-Wrong
@trigger	VisualModelStarted
@when       modeling:ecosystemSelected != "UrchinBarren", !jobs:kelp-urchin-barren.upgradedFacts
@cutscene

{@drKelp}   Ah, hang on, this isn't the right ecosystem.
            Head back to the {h}Ecosystem{/h} tab and select the {nameof UrchinBarren}.
            
:: ModelingSetup-WrongHelp
@trigger	RequestPartnerHelp
@when       modeling:ecosystemSelected != "UrchinBarren" 
@cutscene
{@player}   What do I need to do here?
{@guide}    Remember, we need to open the {nameof UrchinBarren} {h}Ecosystem{/h}.

:: ModelingSetupPhase
@trigger    VisualModelStarted
@when       modeling:ecosystemSelected == "UrchinBarren"
@once
@cutscene

{@drKelp}   Remember how there's a sort of {h}web{/h} that emerges from these facts.
            Now, we can see how you can do more than just create visual models. We are going to {h}simulate ecosystems{/h}.
$if !jobs:kelp-urchin-barren-predict.received.facts
			Let me just send you the missing data needed for this model...

$branch common.download
$call UpgradeFact(Urchin.Eats.GiantKelp, Rate, Batch)
$call UpgradeFact(SeaOtter.Eats.Urchin, Rate)
$call GiveFact(Urchin.Reproduce, Batch)
$call GiveFact(GiantKelp.Reproduce, Batch)
$call GiveFact(SeaOtter.Reproduce)
$set jobs:kelp-urchin-barren-predict.received.facts = true

{@drKelp}   The simulator doesn't really work unless you have numbers to go along with your facts.
            But once you add these, then we should be good to go. 
			Normally you will need to use the {nameof MeasurementTank} to determine rates, but this time we already have the rules on hand.
$endif
            Be sure to hit the {h}Import New Facts{/h} button again before moving on.
            
$set jobs:kelp-urchin-barren.upgradedFacts = true

:: ModelingSetupPhase2
@trigger    VisualModelUpdated
@when       modeling:ecosystemSelected == "UrchinBarren", jobs:kelp-urchin-barren.upgradedFacts
@once
@cutscene

{@drKelp}   Nice, the simulator should be ready for you now.
            Just hit the {h}Describe{/h} button up top to start the simulator up.

::ModelHelp1.A
@trigger    RequestPartnerHelp
@when 		scene:name == "Modeling", modeling:phase == "visual", JobTaskTop("predictSiteB"), modeling:ecosystemSelected == "UrchinBarren", !jobs:kelp-urchin-barren.upgradedFacts
@cutscene
{@player} 	What should I do next?
{@guide}	We have to add our facts to the {h}Visual Model{/h}.
            Use the {h}Import New Facts{/h} button to add the behaviors we've noticed so far. 
            
::ModelHelp1.B
@trigger    RequestPartnerHelp
@when 		scene:name == "Modeling", modeling:phase == "visual", modeling:ecosystemSelected == "UrchinBarren", JobTaskTop("predictSiteB"), jobs:kelp-urchin-barren.upgradedFacts, modeling:hasPendingImport
@cutscene
{@player} 	What should I do next?
{@guide}	They just gave us some new facts to add.
            Let's get those imported!

::ModelHelp1.C
@trigger    RequestPartnerHelp
@when 		scene:name == "Modeling", modeling:phase == "visual", modeling:ecosystemSelected == "UrchinBarren", JobTaskTop("predictSiteB"), jobs:kelp-urchin-barren.upgradedFacts, !modeling:hasPendingImport
@cutscene
{@player} 	What should I do next?
{@guide}	We have everything imported. I think we should start up the simulator.
            Use the {h}Describe{/h} tab on the top to start it.

:: GetSync
@trigger	SimulationModelStarted
@when 		!jobs:kelp-urchin-barren-predict.received.facts
@boostScore 1060 // trigger before V1ctor's sync intro, which is 1051
@once
@cutscene
{@drKelp}	Hold on! Before you get started in here, let me just send you the missing data needed for this model...

$branch common.download
$call UpgradeFact(Urchin.Eats.GiantKelp, Rate, Batch)
$call UpgradeFact(SeaOtter.Eats.Urchin, Rate)
$call GiveFact(Urchin.Reproduce, Batch)
$call GiveFact(GiantKelp.Reproduce, Batch)
$call GiveFact(SeaOtter.Reproduce)
$set jobs:kelp-urchin-barren-predict.received.facts = true

{@drKelp}   The simulator doesn't really work unless you have numbers to go along with your facts.
            But once you add these, then we should be good to go.
			Normally you will need to use the {nameof MeasurementTank} to determine rates, but this time we already have the rules on hand.
			Head back to the {h}Visualize{/h} tab to {h}Import New Facts{/h}, then return here.

::ModelHelp2
@trigger    RequestPartnerHelp
@when 		scene:name == "Modeling", modeling:phase == "sync", JobTaskTop("predictSiteB"), modeling:phase == "describe"
@cutscene
{@player} 	What should I do next?
{@guide}	Let's try hitting the {h}Simulate{/h} button over there.

:: ModelSynced
@trigger	SimulationSyncSuccess
@once
@cutscene
{@drKelp}  Perfect! The model's output lines up with actual past population data, so we know we've created a useful model.
            Now let's see what it predicts will happen next. Hit the {h}Predict{/h} tab.

::ModelHelp3
@trigger    RequestPartnerHelp
@when 		scene:name == "Modeling", modeling:phase == "predict", JobTaskTop("predictSiteB")
@cutscene
{@player} 	What should I do next?
{@guide}	There seems to be a big {h}Run Prediction{/h} button over there...
            Let's give that a test.

:: ModelingGraphComplete
@trigger	SimulationPredictSuccess
@once
@cutscene
{@drKelp}   Nice work! You've just made a {h}model{/h}!
            Now bring that back to the {map-name}research station{/map-name}.
{hide-dialog}
{wait 1}
{@guide}    So it looks like the {pluralnameof GiantKelp} and {pluralnameof Urchin} will sort of stay at a low level.
            That doesn't sound great...

// SUGGEST ARGUMENTATION

:: helpReportBack
@trigger    RequestPartnerHelp
@when 		JobTaskTop(reportBack)
@cutscene
$if scene:name == "Argumentation"
    {@player}   What should I be doing again?
    {@guide}    Report your findings to {nameof @drKelp}.
$elseif !IsPlayerOnStation()
    {@player}   What should we do now?
    {@guide}    Let's report our findings to {nameof @drKelp}.
$else
    {@player} 	What should we do now?
	{@guide}	Well, we've completed the modeling, so let's report back to {nameof @drKelp}.
                We should first head back to the {map-name}research station{/map-name}.
$endif

// CATCH-ALL GUIDE TEXT

:: catchPredictSiteB
@trigger    RequestPartnerHelp
@when 		JobTaskActive(predictSiteB)
@boostScore -5
@cutscene
{@guide}   	Head to the Modeling Lab and generate a Prediction Model.

:: catchReportBack
@trigger    RequestPartnerHelp
@when 		JobTaskActive(reportBack)
@boostScore -5
@cutscene
{@guide}	Let's head back to the {m}research station{/m} and tell {nameof @drKelp} what we found.

// ARGUMENTATION

::argue.intro
@trigger    TryArgumentation
@when   !ArgueIsComplete(urchinBarrenPredictArgue)
@cutscene

$call ArgueLoad(urchinBarrenPredictArgue)
	$if ArgueSetClaim(urchinBarrenPredictClaim, jobs.kelp-urchin-barren-predict.argue.claimLabel)
			$call ArgueFactSlot(UrchinBarren.Model.Prediction)
	$endif

	$branch .argue.hello

	
::argue.hello
{@drKelp}    Let's review, what's our prediction for the {nameof GiantKelp} population?
$goto .argue.chooseFacts

::argue.chooseFacts
$call ArgueDisplayClaim()
$if ArgueAllFactsCorrect()
    $goto .argue.done
$else
    $choice #argueFact; Present facts from AQOS
        $answer UrchinBarren.Model.Prediction, .argue.done
        $answer *, .argue.unrelated
    $choice .argue.giveUp; Let me get back to you
$endif

::argue.unrelated
$if ArgueIsFactSubmitted(Urchin.Eats.GiantKelp)
	{@drKelp}    Do you have a model that predicts what's going to happen at Site B?
$else
	$if ArgueIsFactSubmitted(UrchinBarren.Model.Prediction)
		{@drKelp}  Is something eating the {nameof GiantKelp}?
	$else
		{@drKelp}  I don't know if that's it.
	$endif
$endif
$call ArgueRejectIncorrect()
$goto .argue.chooseFacts

::argue.giveUp
{@drKelp}    OK get back to me when you're ready.

::argue.done
$call ArgueComplete()
{@drKelp}   Ok then... That is rather bleak.
{@player}   Yeah...
{@drKelp}   But don't lose hope yet. I have one last job for you.
$call CompleteJob()
